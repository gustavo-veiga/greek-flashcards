<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><!--JBuilder QuickDoc-->
<HEAD>
<TITLE>Class javax.swing.JList</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY>

<H2>
<FONT SIZE="-1">javax.swing</FONT>
<BR>Class JList</H2>
<DL>
<DT>public class <B>JList</B><DT>extends javax.swing.JComponent<DT>implements javax.swing.Scrollable, javax.accessibility.Accessible
</DL>
<DL><DD>A component that allows the user to select one or more objects from a list. A separate model, <code>ListModel</code>, represents the contents of the list. It's easy to display an array or vector of objects, using a <code>JList</code> constructor that builds a <code>ListModel</code> instance for you: <pre>
// Create a JList that displays the strings in data[]
String[] data = {"one", "two", "three", "four"};
JList dataList = new JList(data);
// The value of the JList model property is an object that provides
// a read-only view of the data.  It was constructed automatically.
for(int i = 0; i < dataList.getModel().getSize(); i++) {
     System.out.println(dataList.getModel().getElementAt(i));
 }

 // Create a JList that displays the superclass of JList.class.
 // We store the superclasses in a java.util.Vector.

 Vector superClasses = new Vector();
 Class rootClass = javax.swing.JList.class;
 for(Class cls = rootClass; cls != null; cls = cls.getSuperclass()) {
     superClasses.addElement(cls);
 }
 JList classList = new JList(superClasses);
 </pre>
<p>
<code>JList</code> doesn't support scrolling directly. 
To create a scrolling
list you make the <code>JList</code> the viewport view of a
<code>JScrollPane</code>.  For example:
<pre>
JScrollPane scrollPane = new JScrollPane(dataList);
// Or in two steps:
JScrollPane scrollPane = new JScrollPane();
scrollPane.getViewport().setView(dataList);
</pre> <p> By default the <code>JList</code> selection model allows any combination of items to be selected at a time, using the constant <code>MULTIPLE_INTERVAL_SELECTION</code>. The selection state is actually managed by a separate delegate object, an instance of <code>ListSelectionModel</code>. However <code>JList</code> provides convenient properties for managing the selection. <pre>
String[] data = {"one", "two", "three", "four"};
JList dataList = new JList(data);
dataList.setSelectedIndex(1);  // select "two"
dataList.getSelectedValue();   // returns "two"
</pre> <p> The contents of a <code>JList</code> can be dynamic, in other words, the list elements can change value and the size of the list can change after the <code>JList</code> has been created. The <code>JList</code> observes changes in its model with a <code>swing.event.ListDataListener</code> implementation. A correct implementation of <code>ListModel</code> notifies it's listeners each time a change occurs. The changes are characterized by a <code>swing.event.ListDataEvent</code>, which identifies the range of list indices that have been modified, added, or removed. Simple dynamic-content <code>JList</code> applications can use the <code>DefaultListModel</code> class to store list elements. This class implements the <code>ListModel</code> interface and provides the <code>java.util.Vector</code> API as well. Applications that need to provide custom <code>ListModel</code> implementations can subclass <code>AbstractListModel</code>, which provides basic <code>ListDataListener</code> support. For example: <pre>
// This list model has about 2^16 elements.  Enjoy scrolling.
<a name="prototype_example">
ListModel bigData = new AbstractListModel() {
public int getSize() { return Short.MAX_VALUE; }
public Object getElementAt(int index) { return "Index " + index; }
};
JList bigDataList = new JList(bigData);
// We don't want the JList implementation to compute the width
// or height of all of the list cells, so we give it a string
// that's as big as we'll need for any cell.  It uses this to
// compute values for the fixedCellWidth and fixedCellHeight
// properties.
bigDataList.setPrototypeCellValue("Index 1234567890");
</pre> <p> <code>JList</code> uses a <code>java.awt.Component</code>, provided by a delegate called the <code>cellRendererer</code>, to paint the visible cells in the list. The cell renderer component is used like a "rubber stamp" to paint each visible row. Each time the <code>JList</code> needs to paint a cell it asks the cell renderer for the component, moves it into place using <code>setBounds()</code> and then draws it by calling its paint method. The default cell renderer uses a <code>JLabel</code> component to render the string value of each component. You can substitute your own cell renderer, using code like this: <pre>
// Display an icon and a string for each object in the list.
<a name="cellrenderer_example">
class MyCellRenderer extends JLabel implements ListCellRenderer {
final static ImageIcon longIcon = new ImageIcon("long.gif");
final static ImageIcon shortIcon = new ImageIcon("short.gif");
// This is the only method defined by ListCellRenderer.
// We just reconfigure the JLabel each time we're called.
public Component getListCellRendererComponent(
JList list,
Object value,            // value to display
int index,               // cell index
boolean isSelected,      // is the cell selected
boolean cellHasFocus)    // the list and the cell have the focus
{
String s = value.toString();
setText(s);
setIcon((s.length() > 10) ? longIcon : shortIcon);
if (isSelected) {
setBackground(list.getSelectionBackground());
setForeground(list.getSelectionForeground());
}
else {
setBackground(list.getBackground());
setForeground(list.getForeground());
}
setEnabled(list.isEnabled());
setFont(list.getFont());
setOpaque(true);
return this;
}
}
String[] data = {"one", "two", "three", "four"};
JList dataList = new JList(data);
dataList.setCellRenderer(new MyCellRenderer());
</pre> <p> <code>JList</code> doesn't provide any special support for handling double or triple (or N) mouse clicks however it's easy to handle them using a <code>MouseListener</code>. Use the <code>JList</code> method <code>locationToIndex()</code> to determine what cell was clicked. For example: <pre>
final JList list = new JList(dataModel);
MouseListener mouseListener = new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
if (e.getClickCount() == 2) {
int index = list.locationToIndex(e.getPoint());
System.out.println("Double clicked on Item " + index);
}
}
};
list.addMouseListener(mouseListener);
</pre> Note that in this example the <code>dataList</code> is <code>final</code> because it's referred to by the anonymous <code>MouseListener</code> class. <p> For the keyboard keys used by this component in the standard look and feel (L&F) renditions, see the <a href="doc-files/Key-Index.html#JList"><code>JList</code> key assignments</a>. <p> <strong>Warning:</strong> Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeans<sup><font size="-2">TM</font></sup> has been added to the <code>java.beans</code> package. Please see <A HREF="java.beans.XMLEncoder">java.beans.XMLEncoder</A>. <p> See <a href="http://java.sun.com/docs/books/tutorial/uiswing/components/list.html">How to Use Lists</a> in <a href="http://java.sun.com/Series/Tutorial/index.html"><em>The Java Tutorial</em></a> for further documentation. Also see the article <a href="http://java.sun.com/products/jfc/tsc/tech_topics/jlist_1/jlist.html">Advanced JList Programming</a> in <a href="http://java.sun.com/products/jfc/tsc"><em>The Swing Connection</em></a>. <p><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Version:</B><DD>1.103 02/11/02</DD>
<DT><B>Author:</B><DD>Hans Muller</DD>
<DT><B>See Also:</B><DD>ListModel</DD>
<DD>AbstractListModel</DD>
<DD>DefaultListModel</DD>
<DD>ListSelectionModel</DD>
<DD>DefaultListSelectionModel</DD>
<DD>ListCellRenderer</DD>
</DL>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B>
</FONT></TD></TR></TABLE>

<H3>uiClassID</H3>
<PRE>
private static final java.lang.String <B>uiClassID</B></PRE>
<DL><DD><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>See Also:</B><DD>#getUIClassID</DD>
<DD>#readObject</DD>
</DL>
<HR>

<H3>VERTICAL</H3>
<PRE>
public static final int <B>VERTICAL</B></PRE>
<DL><DD>Indicates the default layout: one column of cells.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setLayoutOrientation</DD>
</DL>
<HR>

<H3>VERTICAL_WRAP</H3>
<PRE>
public static final int <B>VERTICAL_WRAP</B></PRE>
<DL><DD>Indicates "newspaper style" layout with the cells flowing vertically then horizontally.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setLayoutOrientation</DD>
</DL>
<HR>

<H3>HORIZONTAL_WRAP</H3>
<PRE>
public static final int <B>HORIZONTAL_WRAP</B></PRE>
<DL><DD>Indicates "newspaper style" with the cells flowing horizontally then vertically.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setLayoutOrientation</DD>
</DL>
<HR>

<H3>layoutOrientation</H3>
<PRE>
private int <B>layoutOrientation</B></PRE>
<DL><DD>How to layout the cells, defaults to <code>VERTICAL</code>.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B>
</FONT></TD></TR></TABLE>

<H3>JList</H3>
<PRE>
public <B>JList</B>(javax.swing.ListModel&nbsp;dataModel)</PRE>
<DL><DD>Constructs a <code>JList</code> that displays the elements in the specified, non-<code>null</code> model. All <code>JList</code> constructors delegate to this one.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>dataModel</CODE> - the data model for this list</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if <code>dataModel</code> is <code>null</code></DD>
</DL>
<HR>

<H3>JList</H3>
<PRE>
public <B>JList</B>(java.lang.Object[]&nbsp;listData)</PRE>
<DL><DD>Constructs a <code>JList</code> that displays the elements in the specified array. This constructor just delegates to the <code>ListModel</code> constructor.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listData</CODE> - the array of Objects to be loaded into the data model</DD>
</DL>
<HR>

<H3>JList</H3>
<PRE>
public <B>JList</B>(java.util.Vector&nbsp;listData)</PRE>
<DL><DD>Constructs a <code>JList</code> that displays the elements in the specified <code>Vector</code>. This constructor just delegates to the <code>ListModel</code> constructor.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listData</CODE> - the <code>Vector</code> to be loaded into the data model</DD>
</DL>
<HR>

<H3>JList</H3>
<PRE>
public <B>JList</B>()</PRE>
<DL><DD>Constructs a <code>JList</code> with an empty model.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B>
</FONT></TD></TR></TABLE>

<H3>getUI</H3>
<PRE>
public javax.swing.plaf.ListUI <B>getUI</B>()</PRE>
<DL><DD>Returns the look and feel (L&F) object that renders this component.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>ListUI</code> object that renders this component</DD>
</DL>
<HR>

<H3>setUI</H3>
<PRE>
public void <B>setUI</B>(javax.swing.plaf.ListUI&nbsp;ui)</PRE>
<DL><DD>Sets the look and feel (L&F) object that renders this component.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>ui</CODE> - the <code>ListUI</code> L&F object</DD>
<DT><B>See Also:</B><DD>UIDefaults#getUI</DD>
</DL>
<HR>

<H3>updateUI</H3>
<PRE>
public void <B>updateUI</B>()</PRE>
<DL><DD>Resets the UI property with the value from the current look and feel.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>See Also:</B><DD>UIManager#getUI</DD>
</DL>
<HR>

<H3>getUIClassID</H3>
<PRE>
public java.lang.String <B>getUIClassID</B>()</PRE>
<DL><DD>Returns the suffix used to construct the name of the look and feel (L&F) class used to render this component.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the string "ListUI"</DD>
<DT><B>See Also:</B><DD>JComponent#getUIClassID</DD>
<DD>UIDefaults#getUI</DD>
</DL>
<HR>

<H3>getPrototypeCellValue</H3>
<PRE>
public java.lang.Object <B>getPrototypeCellValue</B>()</PRE>
<DL><DD>Returns the cell width of the "prototypical cell" -- a cell used for the calculation of cell widths, because it has the same value as all other list items.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the <code>prototypeCellValue</code> property</DD>
<DT><B>See Also:</B><DD>#setPrototypeCellValue</DD>
</DL>
<HR>

<H3>setPrototypeCellValue</H3>
<PRE>
public void <B>setPrototypeCellValue</B>(java.lang.Object&nbsp;prototypeCellValue)</PRE>
<DL><DD>Computes the <code>fixedCellWidth</code> and <code>fixedCellHeight</code> properties by configuring the <code>cellRenderer</code> to index equals zero for the specified value and then computing the renderer component's preferred size. These properties are useful when the list is too long to allow <code>JList</code> to compute the width/height of each cell and there is a single cell value that is known to occupy as much space as any of the others. <p> Note that we do set the <code>fixedCellWidth</code> and <code>fixedCellHeight</code> properties here but only a <code>prototypeCellValue PropertyChangeEvent</code> is fired. <p> To see an example which sets this property, see the <a href = #prototype_example>class description</a> above. <p> The default value of this property is <code>null</code>. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>prototypeCellValue</CODE> - the value on which to base <code>fixedCellWidth</code> and <code>fixedCellHeight</code></DD>
<DT><B>See Also:</B><DD>#getPrototypeCellValue</DD>
<DD>#setFixedCellWidth</DD>
<DD>#setFixedCellHeight</DD>
<DD>JComponent#addPropertyChangeListener</DD>
</DL>
<HR>

<H3>getFixedCellWidth</H3>
<PRE>
public int <B>getFixedCellWidth</B>()</PRE>
<DL><DD>Returns the fixed cell width value -- the value specified by setting the <code>fixedCellWidth</code> property, rather than that calculated from the list elements.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the fixed cell width</DD>
<DT><B>See Also:</B><DD>#setFixedCellWidth</DD>
</DL>
<HR>

<H3>setFixedCellWidth</H3>
<PRE>
public void <B>setFixedCellWidth</B>(int&nbsp;width)</PRE>
<DL><DD>Sets the width of every cell in the list. If <code>width</code> is -1, cell widths are computed by applying <code>getPreferredSize</code> to the <code>cellRenderer</code> component for each list element. <p> The default value of this property is -1. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>width</CODE> - the width, in pixels, for all cells in this list</DD>
<DT><B>See Also:</B><DD>#getPrototypeCellValue</DD>
<DD>#setFixedCellWidth</DD>
<DD>JComponent#addPropertyChangeListener</DD>
</DL>
<HR>

<H3>getFixedCellHeight</H3>
<PRE>
public int <B>getFixedCellHeight</B>()</PRE>
<DL><DD>Returns the fixed cell height value -- the value specified by setting the <code>fixedCellHeight</code> property, rather than that calculated from the list elements.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the fixed cell height, in pixels</DD>
<DT><B>See Also:</B><DD>#setFixedCellHeight</DD>
</DL>
<HR>

<H3>setFixedCellHeight</H3>
<PRE>
public void <B>setFixedCellHeight</B>(int&nbsp;height)</PRE>
<DL><DD>Sets the height of every cell in the list. If <code>height</code> is -1, cell heights are computed by applying <code>getPreferredSize</code> to the <code>cellRenderer</code> component for each list element. <p> The default value of this property is -1. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>height</CODE> - an integer giving the height, in pixels, for all cells in this list</DD>
<DT><B>See Also:</B><DD>#getPrototypeCellValue</DD>
<DD>#setFixedCellWidth</DD>
<DD>JComponent#addPropertyChangeListener</DD>
</DL>
<HR>

<H3>getCellRenderer</H3>
<PRE>
public javax.swing.ListCellRenderer <B>getCellRenderer</B>()</PRE>
<DL><DD>Returns the object that renders the list items.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>ListCellRenderer</code></DD>
<DT><B>See Also:</B><DD>#setCellRenderer</DD>
</DL>
<HR>

<H3>setCellRenderer</H3>
<PRE>
public void <B>setCellRenderer</B>(javax.swing.ListCellRenderer&nbsp;cellRenderer)</PRE>
<DL><DD>Sets the delegate that's used to paint each cell in the list. If <code>prototypeCellValue</code> was set then the <code>fixedCellWidth</code> and <code>fixedCellHeight</code> properties are set as well. Only one <code>PropertyChangeEvent</code> is generated however - for the <code>cellRenderer</code> property. <p> The default value of this property is provided by the ListUI delegate, i.e. by the look and feel implementation. <p> To see an example which sets the cell renderer, see the <a href = #cellrenderer_example>class description</a> above. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>cellRenderer</CODE> - the <code>ListCellRenderer</code> that paints list cells</DD>
<DT><B>See Also:</B><DD>#getCellRenderer</DD>
</DL>
<HR>

<H3>getSelectionForeground</H3>
<PRE>
public java.awt.Color <B>getSelectionForeground</B>()</PRE>
<DL><DD>Returns the selection foreground color.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>Color</code> object for the foreground property</DD>
<DT><B>See Also:</B><DD>#setSelectionForeground</DD>
<DD>#setSelectionBackground</DD>
</DL>
<HR>

<H3>setSelectionForeground</H3>
<PRE>
public void <B>setSelectionForeground</B>(java.awt.Color&nbsp;selectionForeground)</PRE>
<DL><DD>Sets the foreground color for selected cells. Cell renderers can use this color to render text and graphics for selected cells. <p> The default value of this property is defined by the look and feel implementation. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>selectionForeground</CODE> - the <code>Color</code> to use in the foreground for selected list items</DD>
<DT><B>See Also:</B><DD>#getSelectionForeground</DD>
<DD>#setSelectionBackground</DD>
<DD>#setForeground</DD>
<DD>#setBackground</DD>
<DD>#setFont</DD>
</DL>
<HR>

<H3>getSelectionBackground</H3>
<PRE>
public java.awt.Color <B>getSelectionBackground</B>()</PRE>
<DL><DD>Returns the background color for selected cells.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>Color</code> used for the background of selected list items</DD>
<DT><B>See Also:</B><DD>#setSelectionBackground</DD>
<DD>#setSelectionForeground</DD>
</DL>
<HR>

<H3>setSelectionBackground</H3>
<PRE>
public void <B>setSelectionBackground</B>(java.awt.Color&nbsp;selectionBackground)</PRE>
<DL><DD>Sets the background color for selected cells. Cell renderers can use this color to the fill selected cells. <p> The default value of this property is defined by the look and feel implementation. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>selectionBackground</CODE> - the <code>Color</code> to use for the background of selected cells</DD>
<DT><B>See Also:</B><DD>#getSelectionBackground</DD>
<DD>#setSelectionForeground</DD>
<DD>#setForeground</DD>
<DD>#setBackground</DD>
<DD>#setFont</DD>
</DL>
<HR>

<H3>getVisibleRowCount</H3>
<PRE>
public int <B>getVisibleRowCount</B>()</PRE>
<DL><DD>Returns the preferred number of visible rows.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>an integer indicating the preferred number of rows to display without using a scroll bar</DD>
<DT><B>See Also:</B><DD>#setVisibleRowCount</DD>
</DL>
<HR>

<H3>setVisibleRowCount</H3>
<PRE>
public void <B>setVisibleRowCount</B>(int&nbsp;visibleRowCount)</PRE>
<DL><DD>Sets the preferred number of rows in the list that can be displayed without a scrollbar, as determined by the nearest <code>JViewport</code> ancestor, if any. The value of this property only affects the value of the <code>JList</code>'s <code>preferredScrollableViewportSize</code>. <p> The default value of this property is 8. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>visibleRowCount</CODE> - an integer specifying the preferred number of visible rows</DD>
<DT><B>See Also:</B><DD>#getVisibleRowCount</DD>
<DD>JComponent#getVisibleRect</DD>
<DD>JViewport</DD>
</DL>
<HR>

<H3>getLayoutOrientation</H3>
<PRE>
public int <B>getLayoutOrientation</B>()</PRE>
<DL><DD>Returns <code>JList.VERTICAL</code> if the layout is a single column of cells, or <code>JList.VERTICAL_WRAP</code> if the layout is "newspaper style" with the content flowing vertically then horizontally or <code>JList.HORIZONTAL_WRAP</code> if the layout is "newspaper style" with the content flowing horizontally then vertically.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the layoutOrientation property</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setLayoutOrientation</DD>
</DL>
<HR>

<H3>setLayoutOrientation</H3>
<PRE>
public void <B>setLayoutOrientation</B>(int&nbsp;layoutOrientation)</PRE>
<DL><DD>Defines the way list cells are layed out. Consider a <code>JList</code> with four cells, this can be layed out in one of the following ways: <pre>
0
1
2
3
</pre> <pre>
0  1
2  3
</pre> <pre>
0  2
1  3
</pre> <p> These correspond to the following values: <table> <tr><td><code>JList.VERTICAL</code> <td>The cells should be layed out vertically in one column. <tr><td><code>JList.HORIZONTAL_WRAP</code> <td>The cells should be layed out horizontally, wrapping to a new row as necessary. The number of rows to use will either be defined by <code>getVisibleRowCount</code> if > 0, otherwise the number of rows will be determined by the width of the <code>JList</code>. <tr><td><code>JList.VERTICAL_WRAP</code> <td>The cells should be layed out vertically, wrapping to a new column as necessary. The number of rows to use will either be defined by <code>getVisibleRowCount</code> if > 0, otherwise the number of rows will be determined by the height of the <code>JList</code>. </table> The default value of this property is <code>JList.VERTICAL</code>. <p> This will throw an <code>IllegalArgumentException</code> if <code>layoutOrientation</code> is not one of <code>JList.HORIZONTAL_WRAP</code> or <code>JList.VERTICAL</code> or <code>JList.VERTICAL_WRAP</code><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>layoutOrientation</CODE> - New orientation, one of <code>JList.HORIZONTAL_WRAP</code>, <code>JList.VERTICAL</code> or <code>JList.VERTICAL_WRAP</code>.</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#getLayoutOrientation</DD>
<DD>#setVisibleRowCount</DD>
<DD>#getScrollableTracksViewportHeight</DD>
</DL>
<HR>

<H3>getFirstVisibleIndex</H3>
<PRE>
public int <B>getFirstVisibleIndex</B>()</PRE>
<DL><DD>Returns the index of the first visible cell. The cell considered to be "first" depends on the list's <code>componentOrientation</code> property. If the orientation is horizontal left-to-right, then the first visible cell is in the list's upper-left corner. If the orientation is horizontal right-to-left, then the first visible cell is in the list's upper-right corner. If nothing is visible or the list is empty, a -1 is returned. Note that the returned cell may only be partially visible.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the index of the first visible cell</DD>
<DT><B>See Also:</B><DD>#getLastVisibleIndex</DD>
<DD>JComponent#getVisibleRect</DD>
</DL>
<HR>

<H3>getLastVisibleIndex</H3>
<PRE>
public int <B>getLastVisibleIndex</B>()</PRE>
<DL><DD>Returns the index of the last visible cell. The cell considered to be "last" depends on the list's <code>componentOrientation</code> property. If the orientation is horizontal left-to-right, then the last visible cell is in the JList's lower-right corner. If the orientation is horizontal right-to-left, then the last visible cell is in the JList's lower-left corner. If nothing is visible or the list is empty, a -1 is returned. Note that the returned cell may only be partially visible.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the index of the last visible cell</DD>
<DT><B>See Also:</B><DD>#getFirstVisibleIndex</DD>
<DD>JComponent#getVisibleRect</DD>
</DL>
<HR>

<H3>ensureIndexIsVisible</H3>
<PRE>
public void <B>ensureIndexIsVisible</B>(int&nbsp;index)</PRE>
<DL><DD>Scrolls the viewport to make the specified cell completely visible. Note, for this method to work, the <code>JList</code> must be displayed within a <code>JViewport</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index</CODE> - the index of the cell to make visible</DD>
<DT><B>See Also:</B><DD>JComponent#scrollRectToVisible</DD>
<DD>#getVisibleRect</DD>
</DL>
<HR>

<H3>setDragEnabled</H3>
<PRE>
public void <B>setDragEnabled</B>(boolean&nbsp;b)</PRE>
<DL><DD>Sets the <code>dragEnabled</code> property, which must be <code>true</code> to enable automatic drag handling (the first part of drag and drop) on this component. The <code>transferHandler</code> property needs to be set to a non-<code>null</code> value for the drag to do anything. The default value of the <code>dragEnabled</code> property is <code>false</code>. <p> When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over a selection and then moves the mouse a few pixels. Setting this property to <code>true</code> can therefore have a subtle effect on how selections behave. <p> Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call the <code>exportAsDrag</code> method of a <code>TransferHandler</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>b</CODE> - the value to set the <code>dragEnabled</code> property to</DD>
<DT><B>Throws:</B><DD><CODE>HeadlessException</CODE> - if <code>b</code> is <code>true</code> and <code>GraphicsEnvironment.isHeadless()</code> returns <code>true</code></DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>java.awt.GraphicsEnvironment#isHeadless</DD>
<DD>#getDragEnabled</DD>
<DD>#setTransferHandler</DD>
<DD>TransferHandler</DD>
</DL>
<HR>

<H3>getDragEnabled</H3>
<PRE>
public boolean <B>getDragEnabled</B>()</PRE>
<DL><DD>Gets the <code>dragEnabled</code> property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the <code>dragEnabled</code> property</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#setDragEnabled</DD>
</DL>
<HR>

<H3>getNextMatch</H3>
<PRE>
public int <B>getNextMatch</B>(java.lang.String&nbsp;prefix,
                        int&nbsp;startIndex,
                        Position.Bias&nbsp;bias)</PRE>
<DL><DD>Returns the next list element that starts with a prefix.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>prefix</CODE> - the string to test for a match</DD>
<DD><CODE>startIndex</CODE> - the index for starting the search</DD>
<DD><CODE>bias</CODE> - the search direction, either Position.Bias.Forward or Position.Bias.Backward.</DD>
<DT><B>Returns:</B><DD>the index of the next list element that starts with the prefix; otherwise -1</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if prefix is null or startIndex is out of bounds</DD>
<DT><B>Since:</B><DD>1.4</DD>
</DL>
<HR>

<H3>getToolTipText</H3>
<PRE>
public java.lang.String <B>getToolTipText</B>(java.awt.event.MouseEvent&nbsp;event)</PRE>
<DL><DD>Overrides <code>JComponent</code>'s <code>getToolTipText</code> method in order to allow the renderer's tips to be used if it has text set. <p> <bold>Note:</bold> For <code>JList</code> to properly display tooltips of its renderers <code>JList</code> must be a registered component with the <code>ToolTipManager</code>. This is done automatically in the constructor, but if at a later point <code>JList</code> is told <code>setToolTipText(null)</code> it will unregister the list component, and no tips from renderers will display anymore.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>See Also:</B><DD>JComponent#getToolTipText</DD>
</DL>
<HR>

<H3>locationToIndex</H3>
<PRE>
public int <B>locationToIndex</B>(java.awt.Point&nbsp;location)</PRE>
<DL><DD>Convert a point in <code>JList</code> coordinates to the closest index of the cell at that location. To determine if the cell actually contains the specified location use a combination of this method and <code>getCellBounds</code>. Returns -1 if the model is empty.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>location</CODE> - the coordinates of the cell, relative to <code>JList</code></DD>
<DT><B>Returns:</B><DD>an integer -- the index of the cell at the given location, or -1.</DD>
</DL>
<HR>

<H3>indexToLocation</H3>
<PRE>
public java.awt.Point <B>indexToLocation</B>(int&nbsp;index)</PRE>
<DL><DD>Returns the origin of the specified item in <code>JList</code> coordinates. Returns <code>null</code> if <code>index</code> isn't valid.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index</CODE> - the index of the <code>JList</code> cell</DD>
<DT><B>Returns:</B><DD>the origin of the index'th cell</DD>
</DL>
<HR>

<H3>getCellBounds</H3>
<PRE>
public java.awt.Rectangle <B>getCellBounds</B>(int&nbsp;index0,
                                        int&nbsp;index1)</PRE>
<DL><DD>Returns the bounds of the specified range of items in <code>JList</code> coordinates. Returns <code>null</code> if index isn't valid.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index0</CODE> - the index of the first <code>JList</code> cell in the range</DD>
<DD><CODE>index1</CODE> - the index of the last <code>JList</code> cell in the range</DD>
<DT><B>Returns:</B><DD>the bounds of the indexed cells in pixels</DD>
</DL>
<HR>

<H3>getModel</H3>
<PRE>
public javax.swing.ListModel <B>getModel</B>()</PRE>
<DL><DD>Returns the data model that holds the list of items displayed by the <code>JList</code> component.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>ListModel</code> that provides the displayed list of items</DD>
<DT><B>See Also:</B><DD>#setModel</DD>
</DL>
<HR>

<H3>setModel</H3>
<PRE>
public void <B>setModel</B>(javax.swing.ListModel&nbsp;model)</PRE>
<DL><DD>Sets the model that represents the contents or "value" of the list and clears the list selection after notifying <code>PropertyChangeListeners</code>. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>model</CODE> - the <code>ListModel</code> that provides the list of items for display</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if <code>model</code> is <code>null</code></DD>
<DT><B>See Also:</B><DD>#getModel</DD>
</DL>
<HR>

<H3>setListData</H3>
<PRE>
public void <B>setListData</B>(java.lang.Object[]&nbsp;listData)</PRE>
<DL><DD>Constructs a <code>ListModel</code> from an array of objects and then applies <code>setModel</code> to it.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listData</CODE> - an array of Objects containing the items to display in the list</DD>
<DT><B>See Also:</B><DD>#setModel</DD>
</DL>
<HR>

<H3>setListData</H3>
<PRE>
public void <B>setListData</B>(java.util.Vector&nbsp;listData)</PRE>
<DL><DD>Constructs a <code>ListModel</code> from a <code>Vector</code> and then applies <code>setModel</code> to it.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listData</CODE> - a <code>Vector</code> containing the items to display in the list</DD>
<DT><B>See Also:</B><DD>#setModel</DD>
</DL>
<HR>

<H3>createSelectionModel</H3>
<PRE>
protected javax.swing.ListSelectionModel <B>createSelectionModel</B>()</PRE>
<DL><DD>Returns an instance of <code>DefaultListSelectionModel</code>. This method is used by the constructor to initialize the <code>selectionModel</code> property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>ListSelectionModel</code> used by this <code>JList</code>.</DD>
<DT><B>See Also:</B><DD>#setSelectionModel</DD>
<DD>DefaultListSelectionModel</DD>
</DL>
<HR>

<H3>getSelectionModel</H3>
<PRE>
public javax.swing.ListSelectionModel <B>getSelectionModel</B>()</PRE>
<DL><DD>Returns the value of the current selection model. The selection model handles the task of making single selections, selections of contiguous ranges, and non-contiguous selections.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the <code>ListSelectionModel</code> that implements list selections</DD>
<DT><B>See Also:</B><DD>#setSelectionModel</DD>
<DD>ListSelectionModel</DD>
</DL>
<HR>

<H3>fireSelectionValueChanged</H3>
<PRE>
protected void <B>fireSelectionValueChanged</B>(int&nbsp;firstIndex,
                                         int&nbsp;lastIndex,
                                         boolean&nbsp;isAdjusting)</PRE>
<DL><DD>Notifies <code>JList</code> <code>ListSelectionListener</code>s that the selection model has changed. It's used to forward <code>ListSelectionEvents</code> from the <code>selectionModel</code> to the <code>ListSelectionListener</code>s added directly to the <code>JList</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>firstIndex</CODE> - the first selected index</DD>
<DD><CODE>lastIndex</CODE> - the last selected index</DD>
<DD><CODE>isAdjusting</CODE> - true if multiple changes are being made</DD>
<DT><B>See Also:</B><DD>#addListSelectionListener</DD>
<DD>#removeListSelectionListener</DD>
<DD>EventListenerList</DD>
</DL>
<HR>

<H3>addListSelectionListener</H3>
<PRE>
public void <B>addListSelectionListener</B>(javax.swing.event.ListSelectionListener&nbsp;listener)</PRE>
<DL><DD>Adds a listener to the list that's notified each time a change to the selection occurs. Listeners added directly to the <code>JList</code> will have their <code>ListSelectionEvent.getSource() == this JList</code> (instead of the <code>ListSelectionModel</code>).<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listener</CODE> - the <code>ListSelectionListener</code> to add</DD>
<DT><B>See Also:</B><DD>#getSelectionModel</DD>
<DD>#getListSelectionListeners</DD>
</DL>
<HR>

<H3>removeListSelectionListener</H3>
<PRE>
public void <B>removeListSelectionListener</B>(javax.swing.event.ListSelectionListener&nbsp;listener)</PRE>
<DL><DD>Removes a listener from the list that's notified each time a change to the selection occurs.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>listener</CODE> - the <code>ListSelectionListener</code> to remove</DD>
<DT><B>See Also:</B><DD>#addListSelectionListener</DD>
<DD>#getSelectionModel</DD>
</DL>
<HR>

<H3>getListSelectionListeners</H3>
<PRE>
public javax.swing.event.ListSelectionListener[] <B>getListSelectionListeners</B>()</PRE>
<DL><DD>Returns an array of all the <code>ListSelectionListener</code>s added to this JList with addListSelectionListener().<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>all of the <code>ListSelectionListener</code>s added or an empty array if no listeners have been added</DD>
<DT><B>Since:</B><DD>1.4</DD>
<DT><B>See Also:</B><DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setSelectionModel</H3>
<PRE>
public void <B>setSelectionModel</B>(javax.swing.ListSelectionModel&nbsp;selectionModel)</PRE>
<DL><DD>Sets the <code>selectionModel</code> for the list to a non-<code>null</code> <code>ListSelectionModel</code> implementation. The selection model handles the task of making single selections, selections of contiguous ranges, and non-contiguous selections. <p> This is a JavaBeans bound property.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>selectionModel</CODE> - the <code>ListSelectionModel</code> that implements the selections</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if <code>selectionModel</code> is <code>null</code></DD>
<DT><B>See Also:</B><DD>#getSelectionModel</DD>
</DL>
<HR>

<H3>setSelectionMode</H3>
<PRE>
public void <B>setSelectionMode</B>(int&nbsp;selectionMode)</PRE>
<DL><DD>Determines whether single-item or multiple-item selections are allowed. The following <code>selectionMode</code> values are allowed: <ul> <li> <code>ListSelectionModel.SINGLE_SELECTION</code> Only one list index can be selected at a time. In this mode the <code>setSelectionInterval</code> and <code>addSelectionInterval</code> methods are equivalent, and only the second index argument is used. <li> <code>ListSelectionModel.SINGLE_INTERVAL_SELECTION</code> One contiguous index interval can be selected at a time. In this mode <code>setSelectionInterval</code> and <code>addSelectionInterval</code> are equivalent. <li> <code>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION</code> In this mode, there's no restriction on what can be selected. This is the default. </ul><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>selectionMode</CODE> - an integer specifying the type of selections that are permissible</DD>
<DT><B>See Also:</B><DD>#getSelectionMode</DD>
</DL>
<HR>

<H3>getSelectionMode</H3>
<PRE>
public int <B>getSelectionMode</B>()</PRE>
<DL><DD>Returns whether single-item or multiple-item selections are allowed.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of the <code>selectionMode</code> property</DD>
<DT><B>See Also:</B><DD>#setSelectionMode</DD>
</DL>
<HR>

<H3>getAnchorSelectionIndex</H3>
<PRE>
public int <B>getAnchorSelectionIndex</B>()</PRE>
<DL><DD>Returns the first index argument from the most recent <code>addSelectionModel</code> or <code>setSelectionInterval</code> call. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the index that most recently anchored an interval selection</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#getAnchorSelectionIndex</DD>
<DD>#addSelectionInterval</DD>
<DD>#setSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getLeadSelectionIndex</H3>
<PRE>
public int <B>getLeadSelectionIndex</B>()</PRE>
<DL><DD>Returns the second index argument from the most recent <code>addSelectionInterval</code> or <code>setSelectionInterval</code> call. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the index that most recently ended a interval selection</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#getLeadSelectionIndex</DD>
<DD>#addSelectionInterval</DD>
<DD>#setSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getMinSelectionIndex</H3>
<PRE>
public int <B>getMinSelectionIndex</B>()</PRE>
<DL><DD>Returns the smallest selected cell index. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the smallest selected cell index</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#getMinSelectionIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getMaxSelectionIndex</H3>
<PRE>
public int <B>getMaxSelectionIndex</B>()</PRE>
<DL><DD>Returns the largest selected cell index. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the largest selected cell index</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#getMaxSelectionIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>isSelectedIndex</H3>
<PRE>
public boolean <B>isSelectedIndex</B>(int&nbsp;index)</PRE>
<DL><DD>Returns true if the specified index is selected. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index</CODE> - index to be queried for selection state</DD>
<DT><B>Returns:</B><DD>true if the specified index is selected</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#isSelectedIndex</DD>
<DD>#setSelectedIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>isSelectionEmpty</H3>
<PRE>
public boolean <B>isSelectionEmpty</B>()</PRE>
<DL><DD>Returns true if nothing is selected. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if nothing is selected</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#isSelectionEmpty</DD>
<DD>#clearSelection</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>clearSelection</H3>
<PRE>
public void <B>clearSelection</B>()</PRE>
<DL><DD>Clears the selection - after calling this method <code>isSelectionEmpty</code> will return true. This is a convenience method that just delegates to the <code>selectionModel</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>See Also:</B><DD>ListSelectionModel#clearSelection</DD>
<DD>#isSelectionEmpty</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setSelectionInterval</H3>
<PRE>
public void <B>setSelectionInterval</B>(int&nbsp;anchor,
                                 int&nbsp;lead)</PRE>
<DL><DD>Selects the specified interval. Both the <code>anchor</code> and <code>lead</code> indices are included. It's not necessary for <code>anchor</code> to be less than <code>lead</code>. This is a convenience method that just delegates to the <code>selectionModel</code>. The <code>DefaultListSelectionModel</code> implementation will do nothing if either <code>anchor</code> or <code>lead</code> are -1. If <code>anchor</code> or <code>lead</code> are less than -1, <code>IndexOutOfBoundsException</code> is thrown.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>anchor</CODE> - the first index to select</DD>
<DD><CODE>lead</CODE> - the last index to select</DD>
<DT><B>Throws:</B><DD><CODE>IndexOutOfBoundsException</CODE> - if either <code>anchor</code> or <code>lead</code> are less than -1</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#setSelectionInterval</DD>
<DD>#addSelectionInterval</DD>
<DD>#removeSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>addSelectionInterval</H3>
<PRE>
public void <B>addSelectionInterval</B>(int&nbsp;anchor,
                                 int&nbsp;lead)</PRE>
<DL><DD>Sets the selection to be the union of the specified interval with current selection. Both the anchor and lead indices are included. It's not necessary for anchor to be less than lead. This is a convenience method that just delegates to the <code>selectionModel</code>. The <code>DefaultListSelectionModel</code> implementation will do nothing if either <code>anchor</code> or <code>lead</code> are -1. If <code>anchor</code> or <code>lead</code> are less than -1, <code>IndexOutOfBoundsException</code> is thrown.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>anchor</CODE> - the first index to add to the selection</DD>
<DD><CODE>lead</CODE> - the last index to add to the selection</DD>
<DT><B>Throws:</B><DD><CODE>IndexOutOfBoundsException</CODE> - if either <code>anchor</code> or <code>lead</code> are less than -1</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#addSelectionInterval</DD>
<DD>#setSelectionInterval</DD>
<DD>#removeSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>removeSelectionInterval</H3>
<PRE>
public void <B>removeSelectionInterval</B>(int&nbsp;index0,
                                    int&nbsp;index1)</PRE>
<DL><DD>Sets the selection to be the set difference of the specified interval and the current selection. Both the <code>index0</code> and <code>index1</code> indices are removed. It's not necessary for <code>index0</code> to be less than <code>index1</code>. This is a convenience method that just delegates to the <code>selectionModel</code>. The <code>DefaultListSelectionModel</code> implementation will do nothing if either <code>index0</code> or <code>index1</code> are -1. If <code>index0</code> or <code>index1</code> are less than -1, <code>IndexOutOfBoundsException</code> is thrown.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index0</CODE> - the first index to remove from the selection</DD>
<DD><CODE>index1</CODE> - the last index to remove from the selection</DD>
<DT><B>Throws:</B><DD><CODE>IndexOutOfBoundsException</CODE> - if either <code>index0</code> or <code>index1</code> are less than -1</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#removeSelectionInterval</DD>
<DD>#setSelectionInterval</DD>
<DD>#addSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setValueIsAdjusting</H3>
<PRE>
public void <B>setValueIsAdjusting</B>(boolean&nbsp;b)</PRE>
<DL><DD>Sets the data model's <code>isAdjusting</code> property to true, so that a single event will be generated when all of the selection events have finished (for example, when the mouse is being dragged over the list in selection mode).<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>b</CODE> - the boolean value for the property value</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#setValueIsAdjusting</DD>
</DL>
<HR>

<H3>getValueIsAdjusting</H3>
<PRE>
public boolean <B>getValueIsAdjusting</B>()</PRE>
<DL><DD>Returns the value of the data model's <code>isAdjusting</code> property. This value is true if multiple changes are being made.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if multiple selection-changes are occurring, as when the mouse is being dragged over the list</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#getValueIsAdjusting</DD>
</DL>
<HR>

<H3>getSelectedIndices</H3>
<PRE>
public int[] <B>getSelectedIndices</B>()</PRE>
<DL><DD>Returns an array of all of the selected indices in increasing order.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>all of the selected indices, in increasing order</DD>
<DT><B>See Also:</B><DD>#removeSelectionInterval</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setSelectedIndex</H3>
<PRE>
public void <B>setSelectedIndex</B>(int&nbsp;index)</PRE>
<DL><DD>Selects a single cell.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>index</CODE> - the index of the one cell to select</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#setSelectionInterval</DD>
<DD>#isSelectedIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setSelectedIndices</H3>
<PRE>
public void <B>setSelectedIndices</B>(int[]&nbsp;indices)</PRE>
<DL><DD>Selects a set of cells.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>indices</CODE> - an array of the indices of the cells to select</DD>
<DT><B>See Also:</B><DD>ListSelectionModel#addSelectionInterval</DD>
<DD>#isSelectedIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getSelectedValues</H3>
<PRE>
public java.lang.Object[] <B>getSelectedValues</B>()</PRE>
<DL><DD>Returns an array of the values for the selected cells. The returned values are sorted in increasing index order.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the selected values or an empty list if nothing is selected</DD>
<DT><B>See Also:</B><DD>#isSelectedIndex</DD>
<DD>#getModel</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getSelectedIndex</H3>
<PRE>
public int <B>getSelectedIndex</B>()</PRE>
<DL><DD>Returns the first selected index; returns -1 if there is no selected item.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the value of <code>getMinSelectionIndex</code></DD>
<DT><B>See Also:</B><DD>#getMinSelectionIndex</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>getSelectedValue</H3>
<PRE>
public java.lang.Object <B>getSelectedValue</B>()</PRE>
<DL><DD>Returns the first selected value, or <code>null</code> if the selection is empty.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the first selected value</DD>
<DT><B>See Also:</B><DD>#getMinSelectionIndex</DD>
<DD>#getModel</DD>
<DD>#addListSelectionListener</DD>
</DL>
<HR>

<H3>setSelectedValue</H3>
<PRE>
public void <B>setSelectedValue</B>(java.lang.Object&nbsp;anObject,
                             boolean&nbsp;shouldScroll)</PRE>
<DL><DD>Selects the specified object from the list.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>anObject</CODE> - the object to select</DD>
<DD><CODE>shouldScroll</CODE> - true if the list should scroll to display the selected object, if one exists; otherwise false</DD>
</DL>
<HR>

<H3>checkScrollableParameters</H3>
<PRE>
private void <B>checkScrollableParameters</B>(java.awt.Rectangle&nbsp;visibleRect,
                                       int&nbsp;orientation)</PRE>
<DL><DD>--- The Scrollable Implementation ---<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<H3>getPreferredScrollableViewportSize</H3>
<PRE>
public java.awt.Dimension <B>getPreferredScrollableViewportSize</B>()</PRE>
<DL><DD>Computes the size of the viewport needed to display <code>visibleRowCount</code> rows. This is trivial if <code>fixedCellWidth</code> and <code>fixedCellHeight</code> were specified. Note that they can be specified implicitly with the <code>prototypeCellValue</code> property. If <code>fixedCellWidth</code> wasn't specified, it's computed by finding the widest list element. If <code>fixedCellHeight</code> wasn't specified then we resort to heuristics: <ul> <li> If the model isn't empty we just multiply the height of the first row by <code>visibleRowCount</code>. <li> If the model is empty, (<code>JList.getModel().getSize() == 0</code>), then we just allocate 16 pixels per visible row, and 256 pixels for the width (unless <code>fixedCellWidth</code> was set), and hope for the best. </ul> If the layout orientation is not <code>VERTICAL</code>, than this will return the value from <code>getPreferredSize</code>. The current <code>ListUI</code> is expected to override <code>getPreferredSize</code> to return an appropriate value.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a dimension containing the size of the viewport needed to display <code>visibleRowCount</code> rows</DD>
<DT><B>See Also:</B><DD>#getPreferredScrollableViewportSize</DD>
<DD>#setPrototypeCellValue</DD>
</DL>
<HR>

<H3>getScrollableUnitIncrement</H3>
<PRE>
public int <B>getScrollableUnitIncrement</B>(java.awt.Rectangle&nbsp;visibleRect,
                                      int&nbsp;orientation,
                                      int&nbsp;direction)</PRE>
<DL><DD>Returns the distance to scroll to expose the next or previous row (for vertical scrolling) or character (for horizontal scrolling). For horizontal scrolling: return the lists font size or 1 if the font is <code>null</code>. We're using the font size instead of the width of some canonical string, e.g. "m", because it's cheaper. <p> For verticaL scrolling: if we're scrolling downwards (<code>direction</code> is greater than 0), and the first row is completely visible with respect to <code>visibleRect</code>, then return its height. If we're scrolling downwards and the first row is only partially visible, return the height of the visible part of the first row. Similarly if we're scrolling upwards we return the height of the row above the first row, unless the first row is partially visible. <p> Note that the value of <code>visibleRect</code> must be the equal to <code>this.getVisibleRect()</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>visibleRect</CODE> - the visible rectangle</DD>
<DD><CODE>orientation</CODE> - HORIZONTAL or VERTICAL</DD>
<DD><CODE>direction</CODE> - if <= 0, then scroll UP; if > 0, then scroll DOWN</DD>
<DT><B>Returns:</B><DD>the distance, in pixels, to scroll to expose the next or previous unit</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if visibleRect is <code>null<code>, or orientation isn't one of SwingConstants.VERTICAL, SwingConstants.HORIZONTAL.</DD>
<DT><B>See Also:</B><DD>Scrollable#getScrollableUnitIncrement</DD>
</DL>
<HR>

<H3>getScrollableBlockIncrement</H3>
<PRE>
public int <B>getScrollableBlockIncrement</B>(java.awt.Rectangle&nbsp;visibleRect,
                                       int&nbsp;orientation,
                                       int&nbsp;direction)</PRE>
<DL><DD>Returns the distance to scroll to expose the next or previous block. For vertical scrolling we are using the follows rules: <ul> <li>if scrolling down (<code>direction</code> is greater than 0), the last visible element should become the first completely visible element <li>if scrolling up, the first visible element should become the last completely visible element <li>visibleRect.height if the list is empty </ul> <p> For horizontal scrolling if the list is layed out horizontally (the orientation is <code>VERTICAL_WRAP</code> or <code>HORIZONTAL_WRAP</code>): <ul> <li>if scrolling right (<code>direction</code> is greater than 0), the next column should become the first visible column <li>if scrolling left, and the beginning of the first column is visible the beginning of the previous column should become visible. If the beginning of the first column is not visible it should become visible. </ul> or visibleRect.width if the list is layed out vertically or list is empty. <p> Note that the value of <code>visibleRect</code> must be the equal to <code>this.getVisibleRect()</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>visibleRect</CODE> - the visible rectangle</DD>
<DD><CODE>orientation</CODE> - HORIZONTAL or VERTICAL</DD>
<DD><CODE>direction</CODE> - if <= 0, then scroll UP; if > 0, then scroll DOWN</DD>
<DT><B>Returns:</B><DD>the block increment amount.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if visibleRect is <code>null</code>, or orientation isn't one of SwingConstants.VERTICAL, SwingConstants.HORIZONTAL.</DD>
<DT><B>See Also:</B><DD>Scrollable#getScrollableUnitIncrement</DD>
</DL>
<HR>

<H3>getScrollableTracksViewportWidth</H3>
<PRE>
public boolean <B>getScrollableTracksViewportWidth</B>()</PRE>
<DL><DD>Returns true if this <code>JList</code> is displayed in a <code>JViewport</code> and the viewport is wider than <code>JList</code>'s preferred width; or if the layout orientation is <code>HORIZONTAL_WRAP</code> and the visible row count is <= 0; otherwise returns
 false.
 If false, then don't track the viewport's width. This allows horizontal
 scrolling if the <code>JViewport</code> is itself embedded in a <code>JScrollPane</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if viewport is wider than the <code>JList</code>'s preferred width, otherwise false</DD>
<DT><B>See Also:</B><DD>Scrollable#getScrollableTracksViewportWidth</DD>
</DL>
<HR>

<H3>getScrollableTracksViewportHeight</H3>
<PRE>
public boolean <B>getScrollableTracksViewportHeight</B>()</PRE>
<DL><DD>Returns true if this <code>JList</code> is displayed in a <code>JViewport</code> and the viewport is taller than <code>JList</code>'s preferred height, or if the layout orientation is <code>VERTICAL_WRAP</code> and the number of visible rows is <= 0;
 otherwise returns false.
 If false, then don't track the viewport's height. This allows vertical
 scrolling if the <code>JViewport</code> is itself embedded in a <code>JScrollPane</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if viewport is taller than <code>Jlist</code>'s preferred height, otherwise false</DD>
<DT><B>See Also:</B><DD>Scrollable#getScrollableTracksViewportHeight</DD>
</DL>
<HR>

<H3>paramString</H3>
<PRE>
protected java.lang.String <B>paramString</B>()</PRE>
<DL><DD>Returns a string representation of this <code>JList</code>. This method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between implementations. The returned string may be empty but may not be <code>null</code>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a string representation of this <code>JList</code>.</DD>
</DL>
<HR>

<H3>getAccessibleContext</H3>
<PRE>
public javax.accessibility.AccessibleContext <B>getAccessibleContext</B>()</PRE>
<DL><DD>Gets the AccessibleContext associated with this JList. For JLists, the AccessibleContext takes the form of an AccessibleJList. A new AccessibleJList instance is created if necessary.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>an AccessibleJList that serves as the AccessibleContext of this JList</DD>
</DL>
<HR>

</BODY>
</HTML>